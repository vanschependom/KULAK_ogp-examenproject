@startuml

skinparam linetype ortho

class AlchemicIngredient {
..attributes..
- {final} amount : double
- {final} unit : Unit
- temperature : Temperature
- type : IngredientType
- state : State
..constructors..
+ AlchemicIngredient(Quantity, IngredientType)
+ AlchemicIngredient(Quantity)
..public methods..
+ getColdness() : int
+ getHotness() : int
+ getTemperature() : int[2]
+ heat() : void
+ cool() : void
+ getSimpleName() : String
+ getFullName() : String
+ getSpecialName() : String
..non-public..
- getTemperatureObject() : Temperature
..checkers..
+ isValidAmount(double) : boolean
+ isValidUnit(Unit) : boolean
+ isValidTemperature(Temperature) : boolean
+ isValidType(Type) : boolean
+ isValidState(State) : boolean
+ moveTo(StorageLocation) : void
..class invariants..
@invar isValidAmount(getAmount())
@invar isValidUnit(getUnit())
@invar isValidTemperature(getTemperatureObject())
@invar isValidType(getType())
@invar isValidState(getState())
}

note right of AlchemicIngredient::AlchemicIngredient(Quantity)
    Bepaalde hoeveelheid standaardingredient, dit is
    IngredientType.DEFAULT (=water)
end note

AlchemicIngredient::type ..> IngredientType
AlchemicIngredient::state ..> State
AlchemicIngredient::temperature ..> Temperature
AlchemicIngredient::unit ..> Unit
AlchemicIngredient "0..*" <-- StorageLocation::ingredients

note right of AlchemicIngredient::getTemperatureObject
    De klasse invariant moet het Temperature object
    kunnen opvragen, in plaats van gewoon een array,
    zoals de publieke getTemperature() teruggeeft.
end note

class IngredientType {
..attributes..
- simpleName : String
- specialName : String
- allowedNameSymbols : char[0..*]
- {final} isMixed : boolean
- {final} standardState : State
- {final} standardTemp : Temperature
- {static} DEFAULT : IngredientType
..constructors..
+ IngredientType(String, Temperature)
..public methods..
+ getStandardTemp() : Temperature
..checkers..
+ canHaveAsName(String) : boolean
+ isValidState() : boolean
+ isValidTemperature() : boolean
..class invariants..
@invar canHaveAsName(getSimpleName())
@invar canHaveAsName(getSpecialName())
@invar isValidState(getStandardState())
@invar isValidTemperature(getStandardTemperature())
}

note right of IngredientType::DEFAULT_INGREDIENT
    Het default ingredientType is water
    en hier kunnen we dus al direct een
    instantie van aanmaken!
end note

IngredientType::state ..> "1" State
IngredientType::temperature ..> "1" Temperature

enum State {
..enum possibilities..
LIQUID,POWDER
}

enum Unit {
..enum possibilities..
DROP, SPOON, VIAL, BOTTLE,
JUG, BARREL, STOREROOM, PINCH,
SACHET, BOX, SACK, CHEST,STOREROOM
..attributes..
spoonEquivalent : double
allowedStates : State[1..*]
}

Unit::allowedStates ..> State

class Temperature {
..attributes..
- hotness : int
- coldness : int
- {static} UPPER_BOUND : long
..public methods..
+ heat(long) : void
+ cool(long) : void
+ getColdness() : int
+ getHotness() : int
+ getTemperature() : int[2]
..checkers..
+ isValidHotness(int) : boolean
+ isValidColdness(int) : boolean
+ isValidTemperature(int[2]) : boolean
..class invariants..
'@invar isValidHotness(getHotness())
'@invar isValidColdness(getColdness())
@invar isValidTemperature(getHotness(),getColdness())
}

note right of Temperature::@
    Volstaat het om enkel de cheker
    isValidTemperature() te hebben,
    indien deze zowel hotness als
    coldness checkt? Of moeten hotness
    en coldness een aparte invar hebben?
end note

abstract class StorageLocation {
..attributes..
- ingredients : ArrayList<AlchemicIngredient>
..checkers..
+ canHaveAsIngredient(AlchemicIngredient) : boolean
..public methods..
+ getNbOfIngredients() : int
# getIngredientAt(int) : AlchemicIngredient
+ add(AlchemicIngredient) : void
+ remove(AlchemicIngredient) : void
..class invariants..
@invar hasProperIngredients()
}

class IngredientContainer extends StorageLocation {
..attributes..
- {final} capacity : Unit
- isDestroyed : boolean
..destructor..
+ destroy()
..checkers..
+ isValidCapacity(Unit) : boolean
..class invariants..
@invar isValidCapacity(getCapacity())
}

IngredientContainer::capacity ..> Unit

note top of IngredientContainer
    Voor de kleinste en grootste units
    bestaan er geen containers.
end note

abstract class Device extends StorageLocation {
WIP
'- ingredients : IngredientContainer
'- result : AlchemicIngredient
'- laboratory : Laboratory
'+ {abstract} addIngredients(IngredientContainer) : void
'+ {static} getResult() : IngredientContainer
'+ {abstract} executeOperation() : void
}
'
abstract class TemperatureDevice extends Device {
WIP
'- temperature : rpg.Temperature
'+ setTemperature(rpg.Temperature) : void
'+ addIngredients(IngredientContainer) : void
}
'
class CoolingBox extends TemperatureDevice {
WIP
'+ executeOperation() : void
}
'
'note "Kunnen maar 1 element bevatten." as N2
'CoolingBox .. N2
'Oven .. N2
'
class Oven extends TemperatureDevice {
WIP
'+ executeOperation() : void
}
'
class Kettle extends Device {
WIP
'+ addIngredients(IngredientContainer) : void
'+ executeOperation() : void
}
'
class Transmogrifier extends Device {
WIP
'+ executeOperation() : void
}

'
class Laboratory extends StorageLocation {
'- capacity : int
'- ingredients : ArrayList<AlchemicIngredient>
'- devices : ArrayList<Device>
'+ storeIngredient(IngredientContainer) : void
'+ obtainIngredient(String, rpg.Quantity) : IngredientContainer
'+ obtainIngredient(String) : IngredientContainer
'+ getOverview() : String
'+ {abstract} execute(Recipe, int) : void
}
'
'Laboratory --> "0..*" AlchemicIngredient
'Laboratory "1" <--> "0..4" Device
'
'class Recipe {
'- operations : Operation[1..*]
'- ingredients : AlchemicIngredient[1..*]
'}
'
'enum Operation {
'ADD,
'HEAT,
'COOL,
'MIX
'}
'
'class RecipeBook {
'- recipes : ArrayList<Recipe>
'+ addRecipe(Recipe) : void
'+ removeRecipe(Recipe) : void
'}
'
'Recipe --> "1..*" Operation : has
'Recipe --> "1..*" AlchemicIngredient : has
'RecipeBook --> "0..*" Recipe : has

@enduml